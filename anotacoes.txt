-Capítulo 1 -- Introdução

1.	Sem dúvida, é interessante manter o histórico do código dos projetos, para entendermos como chegamos até ali. Mas manter esse histórico junto ao código atual, com o decorrer do tempo, deixa nossos projetos confusos, poluídos com trechos e comentários que poderiam ser excluídos sem afetar o funcionamento do sistema.
     Seria bom se houvesse uma maneira de navegarmos pelo código do passado, como uma máquina do tempo para código...

2.	Construir um sistema em equipe é um grande desafio. Nosso código tem que se integrar de maneira transparente e sem emendas com o código de todos os outros membros da nossa equipe.
	Como podemos detectar que estamos alterando o mesmo código que um colega? Como mesclar as alterações que fizemos com as demais alterações da equipe? E como identificar conflitos entre essas alterações? Fazer isso manualmente, com cadernetas ou planilhas e muita conversa parece trabalhoso demais e bastante suscetível a erros e esquecimentos.
	Seria bom que tivéssemos em robô de integração de código, que fizesse todo esse trabalho automaticamente...

3.	Existem ferramentas que funcionam como máquinas do tempo e robôs de integração para o seu código. Elas nos permitem acompanhar as alterações desde as versões mais antigas. Também é possível detectar e mesclar alterações nos mesmos arquivos, além de identificar conflitos, tudo de maneira automática.
	Essas ferramentas são chamadas de sistemas de controle de versão(software com a finalidade de gerenciar diferentes versões no desenvolvimento de um documento qualquer). Esses sistemas são comumente utilizados no desenvolvimento de software para controlar as diferentes versões, histórico e desenvolvimento dos códigos-fontes e também da documentação.
	Nesse tipo de ferramenta, há um repositório(lugar onde se guarda, arquiva, coleciona alguma coisa) que nos permite obter qualquer versão já existente do código. Sempre que quisermos controlar as versões de algum arquivo, temos que informar que queremos rastreá-lo no repositório. A cada mudança que desejamos efetivar, devemos aramazenar as alterações nesse repositório.
	Alterações nos mesmos arquivos são mescladas de maneira automática sempre que possível. Já possíveis conflitos são identificados a cada vez que obtemos as mudanças dos nossos colegas de time.
	Alguns exemplos de sistemas de controle de versão mais antigos são CVS, ClearCase, SourceSafe e SVN(que ainda é bastante usado nas empresas).
	Em meados da década de 2000, surgiram sistemas de controle de versão mais modernos, mais rápidos e confiáveis, como Mercurial, Bazaar e, é claro, Git.

4.	O Git é um sistema de controle de versão que, pela sua estrutura interna, é uma máquina do tempo extremamente rápida e é um robô de integração bem competente.

5.	O GitHub, é uma aplicação Web que possibilita a hospedagem de repositórios Git, além de servir como uma rede social para programadores.

6.	A utilização do Git não é restrita apenas ao desenvolvimento de software, muitos administradores de rede, por exemplo, utilizam o Git para manter o histórico de evolução de arquivos de configuração em servidores.

---------------------------------------
-Capítulo 2 -- Tour prático

1.	É importante nos identificarmos para o Git, informando nosso nome e e-mail. Em um terminal, execute os comandos a seguir:
$ git config --global user.name "<nomeDoUsuario>"
$ git config --glboal user.email "<emailDoUsuario>"

2.	A pasta pessoal (ou home directory, em inglês) é o local dos arquivos de usuário como documentos, fotos, músicas etc.
	Se você não souber onde é pasta pessoal, digite o seguinte comando em um terminal:
$ echo ~

3.	Para transformar o diretório atual em um repositório do Git, basta executar o comando git init, que cria uma pasta oculta com o nome .git:
$ git init

4.	Podemos ver a situação dos arquivos no repositório Git com o comando git status:
$ git status

4.	Para que um arquivo seja rastreado pelo Git, devemos executar o comando git add:
$ git add <nomeDoArquivo>

5.	Após o git add o conteúdo do arquivo passa a ser rastreado pelo Git, mas ainda não foi gravado(ou commitado, em uma linguagem mais técnica) no repositório.

6.	Para gravarmos as mudanças no repositório, devemos executar o comando git commit com a opão -m para informar a mensagem do commit:
$ git commit -m "<mensagemDoCommit>"

7.	Para rastrearmos uma modificação, devemos executar o comando git add novamente:
$ git add <nomeDoArquivoModificado>

8.	Com a modificação rastreada, podemos gravá-la no repositório, com o comando git commit com a opção -m para informar a mensagem do commit:
$ git commit -m "<mensagemDoCommit>"

9.	Para verificar o histórico das alterações gravadas no repositório, podemos executar o comando git log:
$ git log

10.	Para criar um novo repositório no GitHub após criarmos uma conta, primeiramente acessamos a url https://github.com/new, o próximo passo é preencher no campo 'Repository name' com o nome do nosso repositório. Deixe o repositório como Public, para que qualquer pessoa consiga ver seu código. As demais opções podem ficar com os valores padrão. Para finalizar, devemos clicar em 'Create repository'. Pronto foi criado um repositório vazio lá no GitHub.

11.	Devemos apontar o repositório da nossa máquina para o repositório do GitHub. Podemos fazer isso com o comando git remote:
$ git remote add <apelidoParaRepositorioRemoto> <urlDoRepositorioRemoto>

12.	Com o comando anterior, apontamos o nome <apelidoParaRepositorioRemoto> para o repositório lá do GitHub.

13.	Com o repositório remoto configurado, podemos enviar nossas mudanças para o GitHub e, por consequência, para todo o mundo. Para isso, basta executar o comando git push:
$ git push <apelidoDadoAoRepositorioRemoto> <nomeDaBranchParaEnvio>

14.	É possível ver todas as alterações no projeto até agora, através do endereço: https://github.com/<nomeDoUsuario>/<nomeDoRepositorio>/commits/<nomeDaBranch>

15.	Com o projeto no GitHub, qualquer um pode acessar o código e ver o histórico, mesmo sem uma conta. Se a pessoa tiver cadastrada no GitHub, será possível baixar o código. Podemos clonar um repositório hospedado no GitHub em nossa máquina executando o comando git clone:
$ git clone <urlDoRepositorioRemoto>

16.	Git e GitHub não são a mesma coisa. O Git é o sistema de controle de versões, com o qual interagimos na linha de comando. Já o GitHub é uma rede social para programadores que disponibiliza repositórios Git acessíveis remotamente. O GitHub é muito utilizado para projetos open source que possuem vários colaboradores do mundo todo.

---------------------------------------
-Capítulo 3 -- Trabalhando com repositório local

1.	Press release: é uma das principais ferramentas de uma assessoria de imprensa quando o assunto é comunicação externa. Ele consiste basicamente em um texto, de cunho jornalístico, sobre um cliente específico ou sobre o tema do cliente. O press release não é enviado ao público em geral, mas, sim, diretamente ao jornalista, via e-mail. Justamente por isso, o material deve ser pensado para chamar a atenção logo no título, entre outras ações para otimizar essa ferramenta.

2.	O subdiretório oculto chamado .git que é criado após o comando git init, é um repositório do Git completo, que conterá todo o histórico de alterações dos arquivos, entre outras coisas.

3.	Podemos executar git init <nomeDaPasta> se quisermos criar um diretório vazio que já é um repositório Git, ou seja, que já possui o .git.

4.	No caso de termos outros subdiretórios como js para armazenar código Javascript e css para armazenar arquivos CSS, todas as informações desses arquivos serão armazenados no mesmo .git.

5.	Basta o comando git init para criar um repositório com Git, que já cria localmente um repositório completo. Isso é bem mais simples que diversos outros sistemas de controle de versão, como o SVN, que precisavam da configuração de um servidor.

6.	Para verificarmos o estado atual do nosso repositório, devemos executar o comando git status:
$ git status

7.	Para informar que um determinado arquivo deve ser rastreado, utilizamos o comando:
$ git add <nomeDoArquivo>

8.	Podemos rastrear todos esses arquivos de uma vez só com o comando git add da seguinte forma:
$ git add .

9.	O ponto do comando anterior representa todos os arquivos não rastreados do diretório atual e também de todos os seus subdiretórios.

10.	Para rastrear apenas arquivos de um determinado subdiretório, utilizamos o comando git add da seguinte forma:
git add <nomeDoSubdiretório>

11.	Quando informamos para o Git que queremos rastrear um arquivo, executando git add pela primeira vez, o Git coloca esse arquivo em uma área especial do repositório, chamada de stage.

12.	O diretório que contém nossos arquivos é chamado de diretório de trabalho ou working directory, em inglês.

13.	Uma vez que um arquivo passa a ser rastreado pelo Git, depois de colocá-lo na área de stage com o comando git add, cada mudança nesse arquivo é rastreada e também deve ser colocada na área de stage executando o comando git add novamente:
$ git add <nomeDoArquivoModificado>

14.	O Git tem um mecanismo que permite ignorarmos arquivos. Basta criarmos um arquivo chamado .gitignore no diretório principal do nosso projeto, com os nomes dos arquivos que queremos ignorar.

15.	É importante que esse arquivo seja rastreado, porque evoluirá junto com o repositório. Por isso, ao criar o .gitignore, não esqueçã de adicioná-lo à área de stage com o comando git add:
$ git add .gitignore

16.	Se quisermos ignorar todos os arquivos com a extensão .log, por exemplo, colocaríamos *.log no .gitignore. Se quiséssemos ignorar todos os arquivos .bmp do subdiretório imagens, deveríamos inserir imagens/*.bmp.

17.	Há um projeto no GitHub com exemplos de arquivos .gitignore para diversas linguagens de programação e tecnologias: https://github.com/github/gitignore

18.	Para gravar os arquivos e alterações definitivamente no repositório, devemos utilizar o comando git commit com a opção -m para descrever as alterações efetuadas:
$ git commit -m "<mensagemDoCommit>"

19.	É importante que as mensagens descrevam de maneira sucinta as alterações que foram efetuadas.

20.	Após a execução do comando git commit é exibido um código logo antes da mensagem. Esse código serve como um identificador do commit. Na verdade, foram exibidos apenas os primeiros 7 dígitos desse código, que contém 40 caracteres ao todo.

21. O termo commit é comum em qualquer sistema controlador de versão e siginifica gravar novos arquivos e alterações em arquivos existentes em um repositório. Em português, os termos comitar ou comitado são bem corriqueiros, apesar de não existirem nos dicionários.


22.	É possível rastrear as mudanças e comitá-las de uma vez só com a opção -a do comando git commit:
$ git commit -a -m "<mensagemDoCommit>"

23.	A opção -a do comando git commit já efetua o rastreamento das mudanças, adicionando-as à área de stage. Poderíamos juntas as opções -a e -m utilizando -am da seguinte maneira:
$ git commit -am "<mensagemDoCommit>"

24.	Sempre que tivermos um arquivo novo, temos que utilizar o comando git add, para que o Git passe a rastreá-lo. Só então poderemos comitá-lo.
$ git add principal.js

25.	O Git, ao contrário da maioria dos sistemas de controle de versão, possui uma separação entre rastrear as mudanças, adicionando-as na área de stage com o comando git add, e gravar as mudanças no repositório, com o comando git commit.
	Essa separação entre rastrear e gravar permite que as mudanças que fizemos no código sejam agrupadas de maneira lógica. Dessa forma, podemos montar commits menores, que farão mais sentido posterior as revisarmos o histórico do projeto e ajudarão ao mesclarmos nossas mudanças com as dos outros membros do nosso time.

26.	Para verificar o histórico das mudanças gravadas no repositório, ou seja, os commits efetuados, devemos utilizar o comando git log:
$ git log

27. Com o comando git log são listadas as mensagens de todos os commits, junto ao código correspondente, autor e data/hora em que foram efetuados.

28.	Se quisermos mostrar apenas um determinada quantidade de commits devemos utilizar a opção -n do comando git log:
$ git log -n <quantidadeDeCommits>

29. Se quisermos um resumo bem conciso dos commits do nosso projeto, podemos utilizar a opção --oneline do comando git log:
$ git log --oneline

30.	Podemos mostrar um resumo dos arquivos alterados, com o número de linhas adicionadas e removidas, através da opção --stat do comando git log:
$ git log --stat

31. Podemos também combinar as várias opções do comando git log. Por exemplo, para mostrar um resumo das alterações dos últimos commits:
$ git log -n <quantidadeDeCommits> --oneline --stat

32.	A diferença entre os comandos git status e o git log é que, o git status exibe arquivos que estão fora da área de stage, pontos para serem adicionados, e arquivos que estão dentro da área de stage, prontos para serem comitados.
	Já o git log exibe o histórico das mudanças efetivamente gravadas em um repositório. Ou seja, os commits efetuados.

33.	Se quisermos revisar a modificação efetuada, verificando as diferenças entre o arquivo alterado e o que foi comitado anteriormente, podemos usar o comando git diff:
$ git diff

34.	Quando tivermos alterações ainda não rastreadas em mais de um arquivo e quisermos verificar o que mudamos em um arquivo específico, basta passarmos o nome desse arquivo como parâmetro para o git diff:
$ git diff <nomeDoArquivo>

35.	O git diff não poderá ser utilizado para arquivos novos, que ainda não estão sendo rastreados pelo Git (ou seja, que ainda não tiveram o primeiro git add executado).

36.	O comando git diff, quando usando sem parâmetros, mostra a diferença entre os arquivos no diretório de trabalho e a área de stage. Portanto, serve apenas para exibir as mudanças ainda não rastreadas.

37. É possível mostrar as diferenças entre os arquivos na área de stage e a última versão que foi comitada utilizando a opção --staged do comando git diff:
$ git diff --staged

38.	Para exibir tanto as alterações fora da área de stage como as de dentro precisamos descobrir o código do último commit, em seguida utilizamos o comando git diff passando como parâmetro o código do commit:
$ git diff <códigoDoCommit>

39.	Pode ser passado para o comando git diff o parâmetro HEAD que pode estar apontando para o último commit. Porém, não é sempre assim, já que o HEAD pode apontar para commits anteriores.

40.	Podemos usar o comando git diff para verificar as diferenças entre dois commits específicos. Para comparar o que foi alterado no nosso último commit em relação aos dois anteriores, devemos utilizar o git diff passando os códigos desses commits:
$ git diff <commitMenosRecente..<commitMaisRecente>

41.	Podemos obter a mesma saída através do comando:
$ git diff <commitMaisRecente>~<quantidadeDeCommitsImediatamenteAntes>

42.	Se houvesse alguma modificação ainda não comitada, fora ou dentro da área de stage, as linhas alteradas também seriam mostradas na resposta do comando git diff <códigoDoCommit>~<quantidadeDeCommitsImediatamenteAntes>
	Já o comando git diff <commitMenosRecente..<commitMaisRecente> não exibe modificações ainda não comitadas, mas apenas as mudanças que aconteceram entre os dois commits especificados.

43.	O comando git status lista os arquivos modificados e o conteúdo da área de stage. Já o comando git diff mostra detalhadamente quais foram essas modificações, além de permitir verificar mudanças entre dois commits.

44.	A remoção do arquivo e adição na área de stage podem ser realizadas de uma vez só através do comando:
$ git rm <nomeDoArquivo>

45.	Uma outra maneira de adicionar a deleção de um arquivo à área de stage seria executar o comando git add. Porém, esse comando não permite o uso em arquivos removidos, a não ser que seja utilizada a opção --all.
$ git add <nomeDoArquivo> --all

46.	Um detalhe importante é saber que, apesar de o arquivo ter sido removido, seu conteúdo fica gravado no histórico do repositório. Dessa maneira, é possível obtermos qualquer arquivo que já existiu em nosso repositório.
	Porém, se por descuido comitarmos algum arquivo grande e depois deletá-lo, nosso repositório não diminuirá de tamanho, já que o histórico será mantido.

47.	Podemos renomear arquivos executando o comando git mv:
$ git mv <antigoNomeDoArquivo> <novoNomeDoArquivo>

48.	É intessante saber que, se tivéssemos renomeado o arquivo da maneira mais trabalhosa, o Git iria detectar o nosso objetivo, depois que tivéssemos efetuados todos os comandos necessários. Isso acontece porque o Git rastreia o conteúdo dos arquivos, não apenas o nome.

49.	Podemos mover arquivos executando o comando git mv:
git mv <nomeDoArquivo> <novoCaminhoDoArquivo>

50.	Para o Git não há diferença entre um arquivo movido ou renomeado. No fim das contas, aquele conteúdo(o que é efetivamente rastreado) mudou de local.

51. Para desfazer alterações ainda não rastreadas, ou seja, que ainda não estão na área de stage, voltando ao conteúdo anterior do arquivo, utilizamos o comando git checkout da seguinte forma:
$ git checkout -- <nomeDoArquivo>

52.	Caso haja alguma mudança já rastreada no arquivo, dentro da área de stage, ao executarmos o comando git checkout, apenas as alterações indesejadas, fora da stage, serão desfeitas. As mudanças que já estavam na stage permanecerão. Serão desfeitas apenas as alterações, que ainda não tinham sido rastreadas.

53.	Podemos utilizar o comando git checkout para recuperar arquivos removidos acidetalmente/manualmente:
git checkout -- <nomeDoArquivo>

54.	Se quisermos apenas remover da área de stage a mudança efetuada no arquivo, preservando o arquivo modificado, devemos executar o comando git reset:
$ git reset -- <nomeDoArquivo>

55.	Quando utilizado dessa maneira, apenas informando um arquivo que tem mudanças na área de stage, o comando git reset retira o arquivo da stage mas preserva tudo o que foi modificado nesse arquivo.

56.	Se invocarmos o comando git reset sem nenhum parâmetro, serão retirados todos os arquivos da área de stage. As alterações efetuadas nesses arquivos serão preservadas.

57.	No caso de querermos descartar todas as mudanças nos arquivos ao invocarmos git reset, devemos utilizar a opção --hard.
	Há um detalhe importante: a opção --hard retira todos os arquivos da área de stage e desfaz todas as alterações nesses arquivos. No fim das contas, o repositório fica exatamente no estado que estava no último commit:
$ git reset --hard

58.	Se quisermos voltar atrás, desfazendo as alterações no repositório, podemos utilizar o comando git revert:
$ git revert --no-edit <códigoDoCommit>

59.	Em vez de passar o código do último commit como parâmetro para o git revert, poderíamos ter utilizado HEAD que, no nosso caso, aponta para o último commit.

60.	O comando git revert efetua um novo commit com a versão anterior dos arquivos. 

61. No caso de passarmos um código de commit antigo, apenas as alterações feitas naquele commit serão desfeitas. Isso é algo bastante poderoso!
	Imagine que você descubra que um bug veio de uma alteração de determinado commit em um conjunto de arquivos. Apenas com um git revert é possível desfazer as alterações que inseriram o bug.

62.	Uma outra forma de desfazer alterações já comitadas é utilizando o comando git reset seguido da opção --hard e de um código de commit:
$ git reset --hard <códigoDoCommit>

63.	Ao utilizarmos o comando git reset seguido da opção --hard e um código de commit, o histórico do repositório é reescrito.
	Porém, é importante mantermos todas as alterações no repositório, mesmo que indesejadas. Afinal de contas, estamos utilizando um sistema de controle de versão justamente para ter um histórico fiel da evolução do código de nossos projetos.

---------------------------------------
-Capítulo 4 -- Trabalhando com repositório remoto

1.	Um repositório remoto nada mais é do que um repositório Git criado em outro computador, chamado de servidor. Para criarmos um repositório remoto, devemos primeiramente utilizar algum computador da empresa que esteja conectado na rede, e criar o repositório Git do projeto neste computador, que passará a ser o servidor central do projeto.

2.	A criação do repositório remoto é feita com o comando git init, da mesma maneira que fizemos para criar o repositório local, entretanto devemos passar o parâmetro --bare ao comando:
$ git init --bare <nomeDoRepositório>

3.	O parâmetro --bare serve para que o Git não crie um working tree(diretório de trabalho), impedindo que commits sejam efetuados diretamente no servidor. No nosso caso faz sentido, já que os commits serão realizados pelos desenvolvedores, localmente, em seus computadores, e depois esses commits serão enviados e armazenados no repositório remoto, localizado no servidor.

4.	Para ensinar ao Git onde se encontra o nosso repositório remoto, devemos utilizar o comando git remote add, no qual informamos o endereço do repositório remoto. Ao executar o comando git remote add devemos informar o name do repositório remoto e sua url:
git remote add <aliasParaRepositório> file://<endereçoIPDoServidor>/<diretórioDoRepositórioRemoto>

5.	É possível adicionar mais de um repositório remoto, desde que cada um tenha seu nome distinto. Isto pode ser útil se precisarmos enviar os commits para mais de um servidor.

6.	Para listar os repositórios remotos que foram adicionados devemos utilizar o comando git remote:
$ git remote

7.	Para que também seja exibida a url devemos adicionar o parâmetro -v ao comando git remote:
$ git remote -v

8.	O repositório remoto é listado duas vezes quando passado o parâmetro -v. Isso acontece pos o Git permite que tenhamos duas URLs distintas para o mesmo repositório remoto, sendo uma para leitura (fetch) e outra para escrita (push). Isto pode ser útil se precisarmos utilizar protocolos distintos para leitura e escrita.

9.	É possível alterar o name de um reposotório remoto utilizando o comando git remote rename:
$ git remote rename <nomeAtual> <novoNome>

10.	Para alterarmos a url do repositório remoto, podemos utilizar o comando git remote ser-url, passando como parâmetro o name do repositório remoto e a nova url:
$ git remote set-url <nomeDoRepositório> <novaURL>

11.	Para enviar os commits locais, que ainda não existem no servidor, devemos utilizar o comando git push, informando o name do repositório remoto seguindo do nome da branch:
$ git push <nomeDoRepositórioRemoto> <nomeDaBranch>

12.	Para obtermos uma cópia de um repositório Git, devemos utilizar o comando git clone informando a URL do repositório a ser clonado:
$ git clone file://<endereçoIPDoServidor>/<diretórioDoRepositórioRemoto>

13.	Por padrão, o Git criará um diretório com o mesmo nome do repositório remoto, e também já adicionará um repositório remoto com o name origin, que aponta para a URL clonada.

14.	Para que possamos visualizar as alterações e commits realizados, devemos sincronizar o nosso repositório local com o servidor, puxando os novos commits para o nosso repositório local.
	A sincronização do repositório local com o servidor é feita com o uso do comando git pull, onde devemos informar o name do repositório remoto que queremos sincronizar, e o nome da branch local a ser atualizada:
$ git pull <nomeDoRepositórioRemoto> <nomeDaBranchLocal>

15.	O Git é um sistema de controle de versão distribuído, e por isso não depende de um servidor central, diferentemente do CVS e SVN.
	Entretando, é possível trabalhar com o Git de maneira centralizada, onde um servidor será o repositório central, recebendo os commits de todos os desenvolvedores, e estes, por sua vez, sincronizando seus repositórios locais com o servidor, frequentemente, para obter os novos commits. Esta é maneira mais comum de utilização do Git.

16.	Quando adicionamos ou clonamos um repositório Git, devemos informar a url do repositório, que utiliza algum protocolo para comunicação e transferência de dados. O Git suporta quatro protocolos para comunicação e transferência de dados: Local, SSH, Git e HTTP/HTTPS.

17.	O protocolo local pode ser utilizado quando o repositório remoto estiver localizado no mesmo computador em que se encontra o repositório local, ou em outro computador que esteja conectado na mesma rede.
	A utilização do protocolo local é feita com o uso do prefixo file:// na URL do repositório a ser clonado:
$ git clone file://<enderecoDoRepositórioRemoto>

18.	O protocolo SSH é, provavelmente, o mais utilizado por ser rápido, seguro, simples de configurar e por suportar tanto a leitura quanto a escrita de dados.
	O uso do protocolo SSH é feito com a URL seguindo o padrão usuario@servidor:<endereçoIP>/repositório.git.

19.	O Git possui um protocolo próprio, que é similar ao SSH, mas sem o mecanismo de autenticação. Por conta disso, ele acaba sendo mais rápido; entretando não é seguro, e seu uso é apenas para leitura.
	Para clonar um repositório utilizando o protocolo Git, a URL deve possuir o prefixo git://:
$git clone git://<endereçoIP>/<diretórioDoRepositório>

20.	O Git também suporta o protocolo HTTP, que é bastante utilizado quando estamos trabalhando em empresas que possuem um controle rígido de segurança.
	Para clonar um repositório utilizando o protocolo HTTP, a URL deve possuir o prefixo http://:
$ git clone http://<enderecoIP><diretorioDoRepositório>
	
	Também é possível utilizar o protocolo HTTPS, que adiciona uma camada de segurança sobre o HTTP, com a utilização do protocolo SSL/TLS:
$ git clone https://<endereçoIP>/<diretórioDoRepositório>

---------------------------------------
-Capítulo 5 -- Hospedando o repositório no GitHub

1.	Existem alguns serviços para hospedagem de projetos na internet, que permitem a utilização de ferramentas de controle de versão. A ideia é que você possa hospedar seus projetos, juntamente com os repositórios, na internet, e assim será possível acessá-los de qualquer lugar do mundo.
	Dentre os principais serviços que suportam o Git, estão: 
	° GitHub
	° Bitbucket
	° Google Code

2.	O GitHub é também uma ferramenta colaborativa, pois nos permite interagir nos repositórios, por meio de algumas funcionalidades como:
	° Issue Tracker: para criação e gestão de bugs e milestones do projeto;
	° Pull Requests: para que outros usuários possam enviar seus commits com 		  alterações no projeto, ou commits com correções de bugs;
	° Commit Comments: para que os usuários possam comentar e discutir sobre as 	  modificações no código, de um determinado commit.

3.	No GitHub é possível criar organizações, e dentro delas criar equipes, para que então seja possível vincular determinadas usuários a determinadas equipes, bem como vincular as equipes aos repositórios em que elas vão trabalhar. Isso é muito útil para que empresas que possuem muitos projetos e muitos colaboradores, pois permite uma melhor organização.

4.	No GitHub é possível pesquisar por repositórios ou usuários. É possível navegar pelo código-fone, visualizar a descrição do projeto, os commits, os usuários que contribuem para o projeto, e até mesmo baixar o repositório compactado em um arquivo zip.

5.	O GitHub possui alguns planos que podemos contratar, sendo um gratuito, e outros com custos mensais.
	No plano gratuito do GitHub, o usuário não tem nenhum custo, entretanto ele somente poderá cirar repositórios públicos, ou seja, qualquer pessoas poderá encontrar seus repositórios e inclusive ter acesso ao código-fonte.
	Mas muitas empresas possuem projetos que são restritos, e não podem ter o código-fonte acessível a qualquer pessoa. Neste caso, a empresa deverá contratar algum dos planos pagos oferecidos pelo GitHub.
	A diferença entre os planos pagos está na quantidade de repositórios privados que poderão ser criados.

6.	Como utilizamos o protocolo https ao adicionar o repositório remoto, sempre que formos sincronizar nosso repositório local, o Git nos solicitrará o usuário e senha cadastrados no GitHub.

7.	Não é possível enviar commits para repositórios que possimos permissão.

8.	A solução do GitHub para colaboração com projetos open source, foi uma funcionalidade chamada pull requests.

9.	O botão Fork do GitHub criará um cópia do repositório do VRaptor no nosso usuário do GitHub.

10.	Após realizar as alterações e commits no projeto, conseguiremos realizar o push normalmente, pois o repositório remoto no GitHub pertence ao nosso usuário.

11.	Para que os commits sejam integrados ao repositório original do projeto, devemos enviar um Pull Request, solicitando que seja feito um pull dos nossos commits.
	Após criarmos o pull request, o usuario receberá um notificação do GitHub, e poderá efetuar o pull dos nossos commits, integrando-os ao repositório original do projeto. Claro, isso após uma análise das alterações efetuadas em nossos commits.

---------------------------------------
-Capítulo 6 -- Organizando o trabalho com branches

1.	A maioria dos sistemas de controle de versão permite trabalho em paralelo através de branches. Uma branch é uma linha independente de desenvolvimento em que podemos comitar novas versões do código sem afetar outras branches.
	Em muitos sistemas de controle de versão, utilizar branches é algo bastante lento e trabalhoso. Porém, a estrutura interna do Git permite lidarmos com branches de maneira muito rápida e leve.

2.  Para listar as branches do nosso repositório, devemos executar o comando git brunch:
$ git branch

3.  O Git possui por padrão uma branch principal chamada master.

4.  O asterisco (*) na da branch indica que esta é a branch atual, em que estamos trabalhando.

5.  No Git toda branch é basicamente um apontador para um commit. A cada novo commit que fazemos, a branch é movida automaticamente, passando a apontar para esse novo commit. Por isso por padrão , a branch master aponta para o último commit que fizemos.

6.  Se quisermos listar as branches existentes no nosso repositório com os commits associados, poderiamos utilizar a opção -v do comando git branch:
$ git branch -v

7.  É importante sabermos uma das informações que um commit armazena, o commit pai, que é o que foi efetuado anteriormente. Um commit poder ter vários pais.

8.  Podemos observar os commits com seus respectivos pais executando o comando git log com a opção --parents:
$ git log parents

9.  Para verificarmos o commit para o qual a master está apontando passamos a opção --decorate para o comando git log:
$ git log --decorate

10. Juntando as opções, podemos executar git log --oneline --decorate --parents para exibir o histórico resumido do nosso repositório com o commit para o qual a master está apontando e os commits pai de cada commit:
$ git log --oneline --decorate --parents

11. Para criarmos uma nova branch executamos o comando git branch com a seguir:
$ git branch <nomeDaBranch>

12. O HEAD é um apontador especial que indica qual é a branch na qual estamos trabalhando.

13. Para trocarmos de branch devemos executar o comando git checkout:
$ git checkout design

14. O Git checkout, além de trocar a branch atual, também pode ser usado para descartar mudanças de um arquivo que ainda não está na área de stage. Para descartarmos as mudanças devemos executar o comando git chekcout -- <nomeDoArquivo>.
    Na verdade, a opção -- não estritamente necessária. Porém, é uma boa prática, já que serve para informar que se trata de um arquivo. Dessa maneira, ajuda a evitar problemas caso uma branch tenha o mesmo nome de algum arquivo.

15. Para criarmos e mudarmos para uma nova branch de uma só vez, passamos a opção -b para o comando git checkout:
$ git checkout -b loja

16. Para remover uma branch, devemos utilizar a opção -d do comando git branch. Não é possível remover uma branch enquanto estivermos nela:
git branch -d <nomeDaBrunch>

17. Não é possível deletar com a opção -d uma branch que possui commits ainda não aplicados em outras branches.
    Para removermos uma branch que possui commits devemos utilizar a opção -D do comando git branch:
$ git branch -D <nomeDaBranch>

18.	Podemos verificar as branches ainda não mescladas com a opção --no-merged do comando git branch:
$ git branch --no-merged

19.	O comando git branch também tem a opção --merged:
$ git branch --merged

20.	Para juntarmos todas as alterações que fizemos, mesclando-as, podemos utilizar o comando git merge:
$ git merge <nomeDaBranch> -m "<mensagem>"

21.	É importante saber que, quando é efetuado um merge, é criado um novo commit com as alterações que estamos mesclando e com a mensagem que informamos.

22.	Há uma situação em que um git merge não irá gerar um commit de merge: quando a branch de destino não teve nenhum commit a mais desde que a branch a ser mesclada foi criada.
	Esse tipo de merge é chamado de fast-forward.
	É possível evitar o uso de fast-forward, forçando a criação de um commit de merge, utilizando a opção --no-off do comando git merge.

23.	Há uma maneira alternativa de mesclar as alterações de duas branches que simplifica o histórico do projeto. Em vez de utilizar git merge, é possível utilizar o git rebase, onde o histórico dos commits é linearizado:
$ git rebase design

24.	No caso de um fast-forward basta apontar a brach de destino par o commit mais novo da branch sendo mesclada.

25.	O git merge e o git rebase têm o mesmo efeito quando há um fast-forward.

26.	O nome rebase vem da ideia de refazer o commit base de uma branch.
	Para isso o Git precisa criar novos commits, mudando os ancestrais de commits anteriores.

27.	Utilizar merge mantém um registro fiel do que ocorreu com o nosso repositório, mas os commits de merge complicam tarefas como navegar pelo código antigo e revisar código novo.
	Já o rebase simplifica o histórico, mas perdemos informação sobre nosso repositório e alguns commits são reescritos. No caso de conflitos, as coisas podem ficar especialmente complicadas.

---------------------------------------
-Capítulo 7 -- Trabalhando em equipe com branches remotas

1.	No Git, temos branches remotas que apontam para branches que estão nos repositórios remotos configurados.
	Para diferenciá-las das branches locais, o nome de uma branch remota é o nome do remote seguido do nome da branch.
	Ao contrário de branches locais, que são movidas a cada commit, branches remotas só são movidas ao fazermos operações que envolvam comunicação de rede como git push, git pull e também o comando git fetch. Portanto, uma branch remota representa a situação da última vez que houve comunicação com o repositório remoto.

2.	Podemos listar as branches remotas passando a opção -r para o comando git branch:
$ git branch -r

3.	Se quisermos mostrar tanto as branches locais como as remotas, podemos utilizar o comando git branch com a opção -a:
$ git branch -a

4.	Para vermos para quais commits as branches remotas estão apontando, podemos utilizar o comando git branch com a opção -v:
$ git branch -r -v

5.	Para compartilhar uma branch devemos informar os nomes do remote e da branch para o comando git push:
$ git pusch <nomeDoRemote> <nomeDaBranch>

6.	O comando anterior envia para o remote <nomeDoRemote> os commits da branch <nomeDaBranch>

7.	Clonar um repositório nomeando o repositório local:
$ git clone htpps://github.com/<nomeDoUsuario>/<nomeDoRepositório> <repositórioLocalASerCriado>

8.	Criar uma branch local a partir de uma branch remota com o comando git checkout:
$ git checkout -b <nomeDaBranchLocalASerCriada> <nomeDaBranchRemota>

9.	Branches locais criadas a partir de branches remotas são chamadas de tracking branches.

10.	Uma outra maneira, mais sucinta, de criar uma tracking branch é utilizar a opção -t do comando git checkout:
$ git checkout -t <nomeDaBranchRemota>

11.	Para obtermos os commits de uma branch remota no nosso repositório, podemos executar o comando git fetch:
$ git fetch origin

12.	Para mesclarmos branches locais e remotas usamos o comando git merge:
$ git merge <nomeDaBranchASerMesclada> -m "<mensagem>"

13.	Em geral, não queremos alterar o histórico de commits da branch local master. Mas é mais importante ainda evitar mudanças nos commits da branch remota origin/master, que é compartilhada por todos os membros da nossa equipe.
	Uma alternativa bastante utilizada é não comitar diretamente na branch local master, mas em uma outra branch local específica para a funcionalidade sendo desenvolvida. Então, faríamos o rebase da origin/master nesta branch local, que teria seu histórico modificado. Dessa forma, a master ficaria intacta.
	A final da funcionalidade, a branch local da funcionalidade teria um merge feito na branch local master.

14.	Para obtermos e mesclarmos os novos commits de uma branch remota com uma branch local poderíamos ter usado um comando só:
$ git pull

15.	O comando anterior vai ter o mesmo efeito de um git fetch origin seguido de um git merge origin/master.

16.	Se desejássemos que o git pull tivesse um efeito parecido com git fetch origin seguido de um git rebase origin/master, poderiamos ter passado a opção --rebase:
$ git pull --rebase

17. Sugestões de de uso git pull e git pull --rebase:
	° Utilizar um git pull --rebase para obter mudanças remotas. É uma prática segura porque nossos novos commits locais ainda não foram compartilhados, ou seja, outros membros nem sabem da existência desses commits. Por isso alterá-los não traz grandes problemas.
	° Ao trabalharmos em uma nova funcionalidade utilizando uma branch marcamos sua entrega fazendo um merge. Assim, conseguimos ter uma boa ideia de quando a funcionalidade começou a ser desenvolvida e quando foi reintegrada à branch master.
	° Se estivermos trabalhando sozinho na nova funcionalidade, podemos fazer rebases periódicos da master na nossa branch para obter código novo, porém deixando o histórico da branch bem limpo.
	° É interessante fazer o push da nossa branch solitária em um repositório remoto, para backup. Mas é importante evitar que alguém faça checkout.

18.	Para removermos definitivamente uma branch remota lá no GitHub, devemos executar:
$ git push origin :<nomeDaBranch>

19.	No caso da branch lá do servidor ter um nome diferente da branch local, ao deletá-lo devemos utilizar o nome da branch do servidor.
